$date
	Wed Jan 25 17:54:12 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module MLD_15_7_Encoder_test_bench $end
$var wire 1 ! out $end
$var reg 1 " clk $end
$var reg 1 # information_bit $end
$var reg 1 $ reset $end
$var reg 1 % sel $end
$scope module DUT $end
$var wire 1 " clk $end
$var wire 1 & final_flip_flop_output_after_delay $end
$var wire 1 ' gate_input $end
$var wire 1 # information_bit $end
$var wire 1 $ reset $end
$var wire 1 % sel $end
$var wire 1 ! out $end
$var wire 1 ( gate_output $end
$var wire 1 ) ff9_output $end
$var wire 1 * ff8_output $end
$var wire 1 + ff7_output $end
$var wire 1 , ff6_output $end
$var wire 1 - ff5_output $end
$var wire 1 . ff4_output $end
$var wire 1 / ff3_output $end
$var wire 1 0 ff2_output $end
$var wire 1 1 ff1_output $end
$var wire 1 2 ff10_output $end
$var reg 1 3 ff10_input $end
$var reg 1 4 ff1_input $end
$var reg 1 5 ff2_input $end
$var reg 1 6 ff3_input $end
$var reg 1 7 ff4_input $end
$var reg 1 8 ff5_input $end
$var reg 1 9 ff6_input $end
$var reg 1 : ff7_input $end
$var reg 1 ; ff8_input $end
$var reg 1 < ff9_input $end
$scope module FF1 $end
$var wire 1 4 D $end
$var wire 1 " clk $end
$var wire 1 $ reset $end
$var reg 1 1 Q $end
$upscope $end
$scope module FF10 $end
$var wire 1 3 D $end
$var wire 1 " clk $end
$var wire 1 $ reset $end
$var reg 1 2 Q $end
$upscope $end
$scope module FF2 $end
$var wire 1 5 D $end
$var wire 1 " clk $end
$var wire 1 $ reset $end
$var reg 1 0 Q $end
$upscope $end
$scope module FF3 $end
$var wire 1 6 D $end
$var wire 1 " clk $end
$var wire 1 $ reset $end
$var reg 1 / Q $end
$upscope $end
$scope module FF4 $end
$var wire 1 7 D $end
$var wire 1 " clk $end
$var wire 1 $ reset $end
$var reg 1 . Q $end
$upscope $end
$scope module FF5 $end
$var wire 1 8 D $end
$var wire 1 " clk $end
$var wire 1 $ reset $end
$var reg 1 - Q $end
$upscope $end
$scope module FF6 $end
$var wire 1 9 D $end
$var wire 1 " clk $end
$var wire 1 $ reset $end
$var reg 1 , Q $end
$upscope $end
$scope module FF7 $end
$var wire 1 : D $end
$var wire 1 " clk $end
$var wire 1 $ reset $end
$var reg 1 + Q $end
$upscope $end
$scope module FF8 $end
$var wire 1 ; D $end
$var wire 1 " clk $end
$var wire 1 $ reset $end
$var reg 1 * Q $end
$upscope $end
$scope module FF9 $end
$var wire 1 < D $end
$var wire 1 " clk $end
$var wire 1 $ reset $end
$var reg 1 ) Q $end
$upscope $end
$scope module GATE $end
$var wire 1 ' in0 $end
$var wire 1 = in1 $end
$var wire 1 % sel $end
$var reg 1 ( out $end
$upscope $end
$scope module SWITCH $end
$var wire 1 # in0 $end
$var wire 1 & in1 $end
$var wire 1 % sel $end
$var reg 1 ! out $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0=
x<
x;
x:
x9
x8
x7
x6
x5
x4
x3
x2
x1
x0
x/
x.
x-
x,
x+
x*
x)
x(
x'
x&
x%
1$
0#
0"
0!
$end
#5
0<
09
08
06
05
04
0(
03
0;
0:
07
0'
01
00
0/
0.
0-
0,
0+
0*
0)
02
1"
#7
1<
19
18
16
15
14
1(
1'
1!
0&
1#
0$
#10
0"
#15
13
1:
09
17
06
05
1)
1,
1-
1/
10
11
1"
#20
0"
#25
0<
19
15
04
0(
1;
0:
18
07
06
0'
00
0/
1.
0,
1+
12
1"
#27
1<
09
08
16
05
14
1(
1'
0!
1&
0#
#30
0"
#35
0<
0;
19
18
17
1*
0+
0-
0.
1/
1"
#37
1<
09
08
06
15
04
0(
0'
1!
1#
#40
0"
#45
0<
18
07
16
05
01
10
0/
1.
0*
1"
#47
1<
19
08
06
15
14
1(
1'
0!
0#
#50
0"
#55
1:
18
05
1,
0.
11
1"
#57
0<
09
08
16
15
04
0(
1!
1%
#60
0"
#65
03
1;
0:
17
05
01
1/
0,
1+
0)
1"
#70
0"
#75
0'
1<
0;
18
06
02
1*
0+
1.
00
1"
#77
0!
0&
#80
0"
#85
13
0<
19
07
0/
1-
0*
1)
1"
#90
0"
#95
1'
03
1:
08
12
0)
1,
0.
1"
#97
1!
1&
#100
0"
#105
1;
09
0'
0-
1+
02
1"
#107
0!
0&
#110
0"
#115
1<
0:
1*
0,
1"
#120
0"
#125
13
0;
0+
1)
1"
#130
0"
#135
1'
0<
12
0*
1"
#137
1!
1&
#140
0"
#145
03
0)
1"
#150
0"
#155
0'
02
1"
#157
0!
0&
